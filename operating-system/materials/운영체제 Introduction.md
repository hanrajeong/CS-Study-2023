# 운영체제 Introduction
* 운영체제란?
: 하드웨어를 효율적으로 사용할 수 있는 abstraction을 제공하며 사용자에게 편리한 환경을 제공하고 자원의 공유 및 분배를 위한 policy를 결정하여 컴퓨터 시스템 내의 자원을 효율적으로 관리
	* Program이란 컴퓨터에서 실행하기 위해 순차적으로 적힌 명령어의 모음으로 바이너리 형태로 저장되어있다면 Process란 실행되고 있는 프로그램의 abstraction으로 program counter, stack 등을 의미한다. 이때 Process는 domain 보호를 위해 메모리 공간인 address space를 가지고 persistent storage인 file에 읽고 쓴다.
	* Kernel = 자원할당, HW 인터페이스, 보안 등을 담당
	: OS = Kernel / OS = Kernel + GUI + library
* Multiprocessing
: 2개 이상의 작업을 동시에 실행 -> OS는 여러 개의 작업을 메모리에 동시에 유지, 스케줄링 도입 -> CPU 활용도 증가 -> idle 최소화
: 사용자는 실행중인 작업에 대해서는 관여할 수 없음 -> 다른 작업이 수행되기 위해서는 현재 작업이 멈춰야하는데 voluntary yield에 의존 -> 공평성을 유지하고 priority를 고려해야해서 job scheduling으로는 해결이 안됨
* Timesharing
: CPU의 실행시간을 time slie로 나누어 해당 시간동안 CPU를 점유하고 끝나면 양보하면서 스위칭을 통해 동시에 실행 -> 사용자는 실행중인 프로그램에 관여가 가능하고 스위칭이 매우 빈번하게 일어남
: Concurrent 수행이 가능. 
: CPU스위칭 시 각 프로그램의 state를 저장해둠.
: 하나의 job은 fork를 통해 여러 개의 자식 프로세스를 생성할 수 있으며 1개의 프로세스 내에서 여러 쓰레드가 동작할 수 있음.
-> Fork를 통해 자식 프로세스를 생성, 자신이 필요한 기능을 자식 프로세스 형태로 만들어 서로 협력을 통한 작업 수행이 가능함.
	* 프로세스 vs 쓰레드
	프로세스 : 프로세스는 운영체제에서 실행되는 프로그램의 인스턴스로 각각의 프로세스는 별도의 메모리 공간을 할당 받으며, 프로세스 간에는 메모리를 공유하지 않음. 하나의 프로세스는 여러 개의 스레드를 가질 수 있음.
	쓰레드 : 쓰레드는 하나의 프로세스 내에서 실행되는 여러 개의 작업 단위 중 하나로, 프로세스의 메모리 공간을 공유하며, 이를 통해 각각의 쓰레드는 독립적으로 실행될 수 있음.
* 멀티타스킹 문제
: 복잡한 메모리 관리 시스템으로 관리 및 보호 시스템 필요
: Concurrent execution 제공 - 정교한 CPU 스케줄링이 필요
: 필요에 따라서 job들간의 orderly execution이 필요해서 동기화, deadlock발생 가능성

# OS design 
* Mechanism : 무엇을 어떻게 할 것인가
Policy : 무엇이 되게 할 것인가
-> 이렇게 분리함으로서 운영체제 설계를 보다 모듈화할 수 있음.
* Layering : OS의 복잡도를 낮추기 위해서 각 layer를 정의가 명확한 함수들로 구성해서 하나의 레이어는 인접한 레이어와 통신할 수 있게 구성한 것. 설계의 복잡도는 낮출 수 있으나 그로 인해 오버헤드가 발생할 수 있음.
-> 각 레이어의 수정이 다른 레이어와 독립적임
* Kernel : 시스템 자원을 효율적으로 관리하고 응용 프로그램이 하드웨어와 상호작용할 수 있는 인터페이서를 제공, 시스템의 메모리와 CPU 등의 하드웨어 자원을 관리하며, 사용자와 응용 프로그램의 요청(System Call)을 받아 처리함. 보안 및 권한/ 장치 드라이버 관리
-> Kenel Mode : 모든 권한을 가진 실행 모드, 운영체제가 실행되는 모드로 Privilege 명령어 실행 및 레지스터 접근 가능
-> User Mode : 커널 모드에 비해 낮은 권한의 실행 모드로 어플리케이션이 실행되는 모드, Privilege 명령어 실행은 불가능함.
-> 실행 모드 전환 (execution mode switch) : 시스템 보호가 목적으로 system call을 통해 실행됨
 Monolithic Kernel : 커널이 사용자와 같은 주소 공간에 위치하여 주소 공간을 커널 코드와 사용자가 나누어서 사용
	-> 같은 주소 공간에 존재해서 오버헤드가 적음
	-> 하나의 바이너리로 이루어져서 일부 수정이 전체에 영향을 미치고 크기가 커질 수록 유지 보수가 어려우며 버그에 취약한 구조임.
 Microkernel : 커널 서비스를 기능에 따라 모듈화하여 독립된 주소공간에서 실행하며 이 모듈을 각각 커널 서버라 하며 독립된 주소공간으로 구현함. 서버들 간의 통신(IPC)나 서비스 콜 등만 제공
	-> 서로간 의존성이 낮고 불필요한 서비스의 재시작/종료가 가능하며 monolithic보다 안정적
	-> Monolithic 커널보다 낮은 성능을 보임 (독립된 서버들 간의 통신 및 context switching으로 인해)
 Virtualization : 하드웨어와 운영체제가 1:1로 존재하는 구조를 바꿔 하나의 물리적인 컴퓨터에서 여러 개의 가상 머신을 동시에 실행할 수 있는 기술.
	-> 쉬운 자원 할당 및 하드웨어 cost 절감, 소프트웨어와 하드웨어간 의존성을 없에고 OS를 독립적으로 isolate시킴.
 Hypervisor : 가상화된 컴퓨터 하드웨어 자원으로 관리하기 위한 관리 계층이 존재하고 게스트 OS와 하드웨어 사이에 위치하고 있음. 그래서 각 게스트 OS가 각각 서로 다른 가상머신에서 수행되며 서로의 존재를 알 수 없고 Hypervisor는 각 OS간 시스템 자원을 분배하는 등 최소한의 역할을 수행함.
	-> 하나의 물리 컴퓨터에서 여러 종류의 게스트 OS 운용이 가능하고 다른 하드웨어 환경에서 컴파일된 게스트 OS 및 운영프로그램도 실행 가능
	-> 하드웨어를 직접적으로 사용하는 다른 운영체제에 비해 성능이 떨어짐

# 운영체제의 구조 및 I/O basic
* 단일 버스 : 시스템 버스에 여러가지 디바이스가 연결되어 CPU, 메모리, I_O의 속도 격차가 증가하여 병목 현상이 발생할 수 있음, 일반적으로 CPU > Memory >> I_O로 속도의 격차가 커짐
* 계층적 버스 구성 : 속도 격차로 인한 병목 현상을 해결, 접근 빈도가 적고 처리 속도가 느린 장치들은 시스템 버스에 직접 연결하지 않고 I/O버스를 거쳐 연결해서 stall 방지
## I/O basic
* interrupt : 비동기적 이벤트를 처리하기 위한 기법으로, 현재 실행 상태를 저장하고 ISR(Interrupt Service Routine)으로 점플, 저장한 실행상태를 복원, 인터럽트로 중단된 지점부터 다시 시작한다. 인터럽트에는 우선순위가 있으며 하드웨어마다 다르게 설정되어있으나 ISR은 짧아야한다
* Trap : 동기적 이벤트를 처리하기 위한 기법으로 시스템 콜이 예시, Trap Service Routine에 의해 처리되나 동기적 이벤트이므로 상태를 저장/복원하지 않음. 
* Device Model
: 하드웨어 장치는 장치를 제어하는 Controller가 있고 각 Controller가 4종류의 register를 가짐 -> Control/ Status/ Input/ Output register
: 메인 메모리의 일부 영역에 매핑하여 매핑 된 주소만 알면 CPU에 접근 가능. 즉, CPU가 register에 읽고 쓰는 동작을 I/O라고 함.
* I/O 처리 기법
1. Polling : Loop안에서 특정 이벤트의 도착 여부를 계속 확인해서 인터럽트와 반대되는 개념으로, 장치가 매우 빠른 경우 적절하지만 이벤트 도착 시간이 길 경우 부적합하며, 폴링 뒤에 programmed I/O를 수행하게 된다. (데이터 이동) 이 경우 모든 동작은 CPU에 의해 진행됨.
2. DMA(Direct Memory Access): 장치의 상태 확인 및 데이터 이동에는 CPU를 사용하지 않고 DMA를 사용함. -> 결국, CPU와 DMA 간 통신으로 I_O를 수행하는 것. CPU가 DMA에 I_O를 요청하면, DMA가 bus stealing을 통해 I/O와 메인 메모리 사이 데이터 전송을 수행하고 동작을 마치면 CPU에 interrupt를 발생시킴.
-> DMA는 추가적인 하드웨어가 필요하며 이를 최대로 활용하기 위해서는 적당한 parallelism 이 필요
